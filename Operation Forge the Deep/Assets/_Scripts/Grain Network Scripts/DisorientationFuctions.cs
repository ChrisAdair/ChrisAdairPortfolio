using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;
using Unity.Jobs;
using MathNet.Numerics.LinearAlgebra;

public static class DisorientationFunctions {

    //All possible permutations
    private static readonly int[,] perms = new int[24,4]
    {
        {3, 2, 1, 0},
        {3, 2, 0, 1},
        {3, 1, 2, 0},
        {3, 1, 0, 2},
        {3, 0, 2, 1},
        {3, 0, 1, 2},
        {2, 3, 1, 0},
        {2, 3, 0, 1},
        {2, 1, 3, 0},
        {2, 1, 0, 3},
        {2, 0, 3, 1},
        {2, 0, 1, 3},
        {1, 3, 2, 0},
        {1, 3, 0, 2},
        {1, 2, 3, 0},
        {1, 2, 0, 3},
        {1, 0, 3, 2},
        {1, 0, 2, 3},
        {0, 3, 2, 1},
        {0, 3, 1, 2},
        {0, 2, 3, 1},
        {0, 2, 1, 3},
        {0, 1, 3, 2},
        {0, 1, 2, 3}
    };
    private static readonly int[,] signs = new int[16, 4]
    {
        { -1, -1, -1, -1 },
        { -1, -1, -1, 1 },
        { -1, -1, 1, -1 },
        { -1, -1, 1, 1 },
        { -1, 1, -1, -1 },
        { -1, 1, -1, 1 },
        { -1, 1, 1, -1 },
        { -1, 1, 1, 1 },
        { 1, -1, -1, -1 },
        { 1, -1, -1, 1 },
        { 1, -1, 1, -1 },
        { 1, -1, 1, 1 },
        { 1, 1, -1, -1 },
        { 1, 1, -1, 1 },
        { 1, 1, 1, -1 },
        { 1, 1, 1, 1 }
    };
    private static readonly Matrix<double> cubicSpace = Matrix<double>.Build.Dense(24, 4, new double[] {
                                                                                    6.12323399573677e-17,    -5.55111512312578e-17,   -2.77555756156289e-16,   -1.04530142769142e-16,   -1.54320105274290e-16,   1.11022302462516e-16,    -8.65956056235493e-17,   6.12323399573677e-17,    -1.79345371455930e-17,   -0.500000000000000,  0.500000000000000,   -0.500000000000000,  0.500000000000000,   -0.500000000000000,  -0.500000000000000,  -0.500000000000000,  0.500000000000000,   -0.707106781186547,  -0.707106781186548,  0.707106781186548,   -0.707106781186548,  -0.707106781186548,  -0.707106781186548,  1,
                                                                                    0,                         1.90960150532740e-16,    5.55111512312578e-17,    1.11022302462516e-16,    0.707106781186548,   0.707106781186548,        0.707106781186548,         0.707106781186548,      1.00000000000000,       0.500000000000000,    0.500000000000000,   -0.500000000000000,  0.500000000000000,   0.500000000000000,   0.500000000000000,   0.500000000000000,   0.500000000000000,   1.66533453693773e-16,    0,                0,                  5.55111512312578e-17,    -0.707106781186547,  0.707106781186548,   0,
                                                                                    0,                        0.707106781186547,   -0.707106781186548,  -1.00000000000000,   -1.23235650881999e-16,   5.55111512312578e-17,    -0.707106781186548,  0.707106781186548,   1.11022302462516e-16,    0.500000000000000,   -0.500000000000000,  0.500000000000000,   0.500000000000000,   0.500000000000000,   -0.500000000000000,  -0.500000000000000,  0.500000000000000,   0.707106781186548,   0,   0,   -0.707106781186548,  2.34257953344514e-16,    5.55111512312578e-17,    0,
                                                                                    1,   -0.707106781186548,  -0.707106781186548,  -1.79345371455930e-17,   -0.707106781186547,  0.707106781186548,   6.12323399573677e-17,    8.65956056235493e-17,    1.04530142769142e-16,    0.500000000000000,   -0.500000000000000,  -0.500000000000000,  -0.500000000000000,  -0.500000000000000,  -0.500000000000000,  0.500000000000000,   0.500000000000000,   1.11022302462516e-16,    0.707106781186548,   0.707106781186548,   1.11022302462516e-16,    1.22133484194832e-17,    2.77555756156289e-16,    0});

    private static readonly Matrix<double> cubicSymm = Matrix<double>.Build.Dense(24, 3, new double[]
    {
        -0.349928056062447,  0.869711453315441,   0.348069452196399,   0.348069452196399,   -0.869711453315440,  -0.349928056062447,  -0.348069452196399,  0.869711453315441,   -0.349928056062447,  -0.349928056062447,  -0.869711453315440,  -0.348069452196399,  0.349928056062447,   0.869711453315441,   -0.348069452196398,  -0.348069452196398,  -0.869711453315440,  0.349928056062447,   0.348069452196399,   0.869711453315441,   0.349928056062447,   0.349928056062447,   -0.869711453315440,  0.348069452196398,
        0.348069452196399,   -0.349928056062447,  0.869711453315440,   -0.349928056062447,  0.348069452196399,   -0.869711453315440,  -0.349928056062447,  -0.348069452196399,  0.869711453315441,   -0.348069452196399,  -0.349928056062447,  -0.869711453315440,  -0.348069452196399,  0.349928056062447,  0.869711453315441,   0.349928056062447,   -0.348069452196398,  -0.869711453315441,  0.349928056062447,   0.348069452196399,   0.869711453315440,   0.348069452196399,   0.349928056062447,   -0.869711453315440,
        0.869711453315441,   0.348069452196399,   -0.349928056062447,  -0.869711453315440,  -0.349928056062447,  0.348069452196399,   0.869711453315441,   -0.349928056062447,  -0.348069452196399,  -0.869711453315441,  -0.348069452196399,  -0.349928056062447,  0.869711453315441,   -0.348069452196399,  0.349928056062447,   -0.869711453315441,  0.349928056062447,   -0.348069452196398,  0.869711453315441,   0.349928056062447,   0.348069452196399,   -0.869711453315440,  0.348069452196398,   0.349928056062447
    });
    private static readonly Matrix<double> cubicAxes = Matrix<double>.Build.Dense(24, 4, new double[]
    {
        1, 0.500000000000000, -0.500000000000000, 6.12323399573677e-17, -0.707106781186547, -0.707106781186548, 0.707106781186548, 1.11022302462516e-16, -0.707106781186548, -1.79345371455930e-17, -0.500000000000000, -0.500000000000000, 6.12323399573677e-17, -0.500000000000000, -0.500000000000000, -8.65956056235493e-17, -1.54320105274290e-16, -5.55111512312578e-17, -0.707106781186548, -0.707106781186548, -2.77555756156289e-16, -1.04530142769142e-16, 0.500000000000000, 0.500000000000000,
        0, 0.500000000000000, 0.500000000000000, 0.707106781186548, 1.66533453693773e-16, -0.707106781186547, 0, 0.707106781186548, 0.707106781186548, 1.00000000000000, 0.500000000000000, -0.500000000000000, 0, 0.500000000000000, 0.500000000000000, 0.707106781186548, 0.707106781186548, 1.90960150532740e-16, 0, 5.55111512312578e-17, 5.55111512312578e-17, 1.11022302462516e-16, 0.500000000000000, 0.500000000000000,
        0, 0.500000000000000, 0.500000000000000, 0.707106781186548, 0.707106781186548, 2.34257953344514e-16, 0, 5.55111512312578e-17, 5.55111512312578e-17, 1.11022302462516e-16, 0.500000000000000, 0.500000000000000, 0, -0.500000000000000, -0.500000000000000, -0.707106781186548, -1.23235650881999e-16, 0.707106781186547, 0, -0.707106781186548, -0.707106781186548, -1.00000000000000, -0.500000000000000, 0.500000000000000,
        0, 0.500000000000000, 0.500000000000000, 8.65956056235493e-17, 1.11022302462516e-16, 1.22133484194832e-17, 0.707106781186548, 0.707106781186548, 2.77555756156289e-16, 1.04530142769142e-16, -0.500000000000000, -0.500000000000000, 1, 0.500000000000000, -0.500000000000000, 6.12323399573677e-17, -0.707106781186547, -0.707106781186548, 0.707106781186548, 1.11022302462516e-16, -0.707106781186548, -1.79345371455930e-17, -0.500000000000000, -0.500000000000000
    });
    private static readonly float sqSave = Mathf.Sqrt(2.0f) + 1;
    public static Quaternion Disorientation(char sym, Quaternion misorientation)
    {
        Quaternion error = Quaternion.identity;
        switch (sym)
        {
            case 'c':
                return Cubic(misorientation);
            case 'b':
                return BetterCubic(misorientation);
            default:
                return error;
        }
    }

    private static Quaternion Cubic(Quaternion mis)
    {
        Quaternion disorientation = Quaternion.identity;

        //Equivalent misorientations
        float[,] equations = new float[6, 4] {
            { mis.w,mis.x,mis.y,mis.z },
            { 0.707107f * (mis.w + mis.x), 0.707107f * (mis.w - mis.x), 0.707107f * (mis.y + mis.z), 0.707107f * (mis.y - mis.z) },
            { 0.707107f * (mis.w + mis.y), 0.707107f * (mis.w - mis.y), 0.707107f * (mis.x + mis.z), 0.707107f * (mis.x - mis.z) },
            { 0.707107f * (mis.w + mis.z), 0.707107f * (mis.w - mis.z), 0.707107f * (mis.x + mis.y), 0.707107f * (mis.x - mis.y) },
            { 0.5f * (mis.w + mis.x + mis.y + mis.z), 0.5f * (mis.w + mis.x - mis.y - mis.z), 0.5f * (mis.w - mis.x + mis.y - mis.z), 0.5f * (mis.w - mis.x - mis.y + mis.z) },
            { 0.5f * (mis.w + mis.x + mis.y - mis.z), 0.5f * (mis.w + mis.x - mis.y + mis.z), 0.5f * (mis.w - mis.x + mis.y + mis.z), 0.5f * (mis.w - mis.x - mis.y - mis.z) }
        };

        bool isDis = false;
        for(int i = 0; i < 6; i++)
        {
            for(int j = 0; j < 16; j++)
            {
                for(int k = 0; k < 24; k++)
                {
                    float a = equations[i,perms[k,0]] * signs[j,0];
                    float b = equations[i,perms[k,1]] * signs[j,1];
                    float c = equations[i,perms[k,2]] * signs[j,2];
                    float d = equations[i,perms[k,3]] * signs[j,3];

                    isDis = (b >= c & c >= d & d >= 0) & (b <= (sqSave-2) * a) & (b + c + d <= a);

                    bool supl = isDis & a == sqSave * b;
                    if (supl)
                        isDis = c <= sqSave * d;
                    if (isDis)
                    {
                        disorientation = new Quaternion(b, c, d, a);
                        break;
                    }
                        
                }
                if (isDis) break;
            }
            if (isDis) break;
        }

        return disorientation;
    }

    //From the mtex project2FundamentalRegion, specifically tailored to the cubic space
    private static Quaternion BetterCubic(Quaternion mis)
    {
        Quaternion output = new Quaternion();

        double minAngle = 0.785398163397448;
        Quaternion rotated = new Quaternion();
        if (2 * Math.Acos(Math.Abs(mis.w)) > minAngle)
        {
            Vector<double> quat = Vector<double>.Build.Dense(new double[] { mis.w, mis.x, mis.y, mis.z });
            //Need to find the inverse of each row for the cubic space in the next line
            Vector<double> temp = cubicSpace.Row((quat * cubicSpace.Transpose()).AbsoluteMaximumIndex()/4);

            rotated = mis * new Quaternion((float)temp[1], (float)temp[2], (float)temp[3], (float)temp[0]);
        }
        else
            rotated = mis;

        Vector<double> axis = Vector<double>.Build.Dense(new double[] { rotated.x, rotated.y, rotated.z });
        if (rotated.w < 0)
            axis = -axis;
        //Missing the check for the null norm here, not sure what the purpose of it is
        axis = axis.Normalize(2);
        //Ended in the vector 3 project2FundamentalRegion
        int index = (axis * cubicSymm.Transpose()).AbsoluteMaximumIndex();
        Vector<double> cAx = cubicAxes.Row(index);
        //inverse of cAx rotating axis
        double s = 2 * (axis[0] * (-cAx[1]) + axis[1] * (-cAx[2]) + axis[2] * (-cAx[3]));
        double aN = Math.Pow(cAx[0],2) - cAx.SubVector(1, 3).Norm(2);
        //x y z = 
        //0 1 2
        //a b c d = 
        //0 1 2 3
        axis[0] = 2 * cAx[0] * ((-cAx[2]) * axis[2] + axis[1] * cAx[3]) + s * (-cAx[1]) + aN * axis[0];
        axis[1] = 2 * cAx[0] * ((-cAx[3]) * axis[0] + axis[2] * cAx[1]) + s * (-cAx[2]) + aN * axis[1];
        axis[2] = 2 * cAx[0] * ((-cAx[1]) * axis[1] + axis[0] * cAx[2]) + s * (-cAx[3]) + aN * axis[2];

        output = Quaternion.AngleAxis((float) (2 * Math.Acos(Math.Abs(rotated.w))), new Vector3((float) axis[0], (float) axis[1], (float) axis[2]));

        return output;
    }
}
